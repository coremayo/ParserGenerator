Project Report - Parser Generator
CS 3240 Spring 2010
James Jones
James King
Corey Mayo
==================================

------------------
1. Implementation
------------------

We implemented our project in Java 1.6. Our very first step was to rewrite the TINY grammar;
then we used the Java Scanner class to build a simple lexer to take in strings of sample
programs and output the associated tokens.

To assist in this first part, we created an enum class specific to TINY called LexicalClass.
This class holds the set of TINY tokens and a parseToken() method to parse them from an
input string. We wrote a simple driver to scan some simple TINY programs and check them
for output.

Next, we split the work in the parser generator. After building the shell classes for 
entities such as Grammar, Symbol, and Rule, Corey worked on the code to build parse tables,
including building the first and follow sets. Bobby and Andy developed the Grammar
methods to remove left recursion and handle left-factoring, using the algorithms described
in the Louden text.  They also wrote the driver that uses the Parse Table and the input 
received from the the lexical anaylis to check for valid syntax, using the LL(1) algorithm from
the Louden Book.

Many test cases were written to thouroughly test that grammars were getting properly parsed, 
parse tables were properly generated, and so on with various grammars from the Louden Book
as well as from the example grammars given to us.  Then, when we combined everything together,
it was succesfully telling us whether or not the input was valid in the grammar.

Also, we created a custom exception, InvalidSyntaxException, to throw on two occasions:
	1. When the parser reads in input and no ParseAction (rule) exists in the ParseTable for
		the given input.
	2. When the parser has finished, but finds that either the parsing stack or	input contains
		further symbols (both are not $ at the end).

------------------
2. Assumptions
------------------
1.  We assumed that no inputted grammar would have any indirect left recursion.
2.  We assumed that for the tiny language for the lexical analysis, there were 
  spaces between every token except for the semicolon, which would immediately 
  follow a token.
3.  We assumed that any file that is being put in would be a valid LL(1) grammar.

------------------
3. Problems/Bugs
------------------
The first major issue was that we committed broken "refactored" code.  That on top of not knowing git
too well led us to having some headaches last minute.  Other issues that arose were minor and easy to
fix, such as pushing symbols onto the stack in the wrong order, having multiple identical rules in our 
grammar, and other really easy problems to fix.  